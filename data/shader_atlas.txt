//No lights
nolights pixel.vs nolights.fs

//Forward pipeline shaders
forward pixel.vs forward.fs

//Deferred pipeline shaders
gbuffers pixel.vs gbuffers.fs
emissive quad.vs emissive.fs
deferred_illumination_sphere pixel.vs deferred.fs
deferred_illumination_quad quad.vs deferred.fs

//Depth map shaders
depth depth.vs color.fs
linearize quad.vs linearize.fs
linearize_atlas quad.vs linearize_atlas.fs

\normal_mapping

mat3 cotangent_frame(in vec3 N, in vec3 p, in vec2 uv)
{
	// get edge vectors of the pixel triangle
	vec3 dp1 = dFdx( p );
	vec3 dp2 = dFdy( p );
	vec2 duv1 = dFdx( uv );
	vec2 duv2 = dFdy( uv );
	
	// solve the linear system
	vec3 dp2perp = cross( dp2, N );
	vec3 dp1perp = cross( N, dp1 );
	vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
	vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
 
	// construct a scale-invariant frame 
	float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );
	return mat3( T * invmax, B * invmax, N );
}

vec3 perturbNormal(in vec3 N, in vec3 WP, in vec2 uv, in vec3 normal_pixel)
{
	normal_pixel = normal_pixel * 255./127. - 128./127.;
	mat3 TBN = cotangent_frame(N, WP, uv);
	return normalize(TBN * normal_pixel);
}

\shadow_test

float testShadowMap(const in float shadow_index, const in float shadows_bias, const in mat4 shadow_vp, const in float num_shadows, 
	const in sampler2D shadow_atlas, const in vec3 world_position)
{
	//project our 3D position to the shadowmap
	vec4 proj_pos = shadow_vp * vec4(world_position,1.0);

	//from homogeneus space to clip space
	vec2 shadow_uv = proj_pos.xy / proj_pos.w;

	//from clip space to uv space
	shadow_uv = shadow_uv * 0.5 + vec2(0.5);

	//In case the point we are painting is out of the shadowm frustrum, it doesn't cast a shadow
	if( shadow_uv.x < 0.0 || shadow_uv.x > 1.0 || shadow_uv.y < 0.0 || shadow_uv.y > 1.0 ) return 1.0;

	//Shadow atlas coordinates
	shadow_uv.x = (shadow_uv.x + shadow_index)/num_shadows;

	//read depth from depth buffer in [0..+1] non-linear
	float shadow_depth = texture2D( shadow_atlas, shadow_uv).x;

	//get point depth [-1 .. +1] in non-linear space
	float real_depth = (proj_pos.z - shadows_bias) / proj_pos.w;

	//normalize from [-1..+1] to [0..+1] still non-linear
	real_depth = real_depth * 0.5 + 0.5;

	//In case the point we are painting is before the near or behind the far plane of the light camera, it doesn't cast a shadow
	if(real_depth < 0.0 || real_depth > 1.0) return 1.0;

	//compute final shadow factor by comparing
	float shadow_factor = 1.0;

	//we can compare them, even if they are not linear
	if( shadow_depth < real_depth ) shadow_factor = 0.0;

	//Return shadow factor
	return shadow_factor;
}

\phong

vec3 PhongEquation(const in vec3 light_color, const in vec3 L, const in float light_intensity, const float light_attenuation, 
	const in vec3 N, const in vec3 V, const in float metalness, const in float roughness, const float shadow_factor, 
	const in bool specular_light)
{
	//Compute R vector
	vec3 R = reflect(-L, N);
    R = normalize(R);

    //Compute dot products
    float NdotL = clamp(dot(N,L), 0.0, 1.0);
    float RdotV = clamp(dot(R,V), 0.0, 1.0);

    //Compute shininess factor
    float shininess_factor = metalness * 20.0; //Multiply metallness by a float to reduce specular inaccuracy

    //Compute light factors
    float diffuse_factor = light_attenuation * NdotL;
    float specular_factor = 0.0;
    if(specular_light) specular_factor = light_attenuation * roughness * pow(RdotV, shininess_factor); 

    //Phong equation
	vec3 light = (diffuse_factor + specular_factor) * light_color * light_intensity * shadow_factor;

	//Return light
	return light;
}

\PBR

//PBR uniforms and constants
#define RECIPROCAL_PI 0.3183098861837697
#define PI 3.14159265358979323846
uniform int u_diffuse_reflection;
uniform int u_geometry_shadowing;

// Walter GGX Normal Distribution
float D_Walter_GGX (const in float NdotH, const in float linear_roughness )
{
	float a = linear_roughness * linear_roughness;
	float f = (NdotH * NdotH) * (a - 1.0) + 1.0;
	return a / (PI * f * f);
}

//Schlick Fresnel Function
float F_Schlick( const in float VdotH, const in float f0)
{
	//Scalar fresnel
	float f = pow(1.0 - VdotH, 5.0);
	return f0 + (1.0 - f0) * f;
}

// Schlick Fresnel Function
vec3 F_Schlick( const in float VdotH, const in vec3 f0)
{
	//Colorized fresnel
	float f = pow(1.0 - VdotH, 5.0);
	return f0 + (vec3(1.0) - f0) * f;
}

//Schlick Fresnel Function
float F_Schlick(const float u, const float f0, const float f90) {
    return f0 + (f90 - f0) * pow(1.0 - u, 5.0);
}

// Smith G1 Aproximation
float G1(const in float vectors_dot, const in float k){
	return vectors_dot / (vectors_dot * (1.0 - k) + k);
}

//Smith G2 Aproximation
float G2(const in float NdotL, const in float NdotV, const in float k)
{
	float product = 2 * NdotL * NdotV;
	return product / 2 * mix(product,NdotL + NdotV, k);
}

//Smith Geometric Shadowing
float G_SmithGGXCorrelated(const in float NdotV, const in float NdotL, const in float roughness)
{
	float k = pow(roughness + 1.0, 2.0) / 8.0;
	
	if(u_geometry_shadowing == 0) //G1 aproximation
	{
		return G1(NdotL, k) * G1(NdotV, k);
	}
	else if(u_geometry_shadowing == 1) // G2 aproximation
	{
		return G2(NdotL,NdotV,k);
	}

}

//Cook-Torrance specular reflection model
vec3 specularBRDF( const in float roughness, const in vec3 f0, const in float NdotH, const in float NdotV, const in float NdotL, const in float LdotH )
{
	//Alpha coefficient
	float a = roughness * roughness;

	// Normal Distribution Function
	float D = D_Walter_GGX( NdotH, a );

	// Fresnel Function
	vec3 F = F_Schlick( LdotH, f0 );

	// Visibility Function (shadowing/masking)
	float G = G_SmithGGXCorrelated(NdotV, NdotL, roughness);
			
	//Compute specular reflection
	vec3 specular_reflection = D * G * F;

	//Normalize specular reflection
	specular_reflection /= (4.0 * NdotL * NdotV + 1e-6);

	//Cook-Torrance specular
	return specular_reflection;
}

//Burley Diffuse Reflections
float BurleyBRDF ( const in float NdotV, const in float NdotL, const in float LdotH, const in float linear_roughness)
{
    float a = linear_roughness * linear_roughness;
    float f90 = 0.5 + 2.0 * a * LdotH * LdotH;
    float light_scatter = F_Schlick(NdotL, 1.0, f90);
    float view_scatter  = F_Schlick(NdotV, 1.0, f90);
    return light_scatter * view_scatter * RECIPROCAL_PI;
}

//Phong Diffuse Reflections
float LambertBRDF() {
    return 1.0 / PI;
}

vec3 BRDF(const in vec3 L, const in vec3 V, const in vec3 N, const in vec3 albedo, const in float metalness, const in float linear_roughness, 
	const in vec3 light_color, const in float light_intensity, const in float light_attenuation, const in float shadow_factor, const in bool specular_light)
{
	//Compute half vector
	vec3 H = (L + V) / length(L + V);

	//Compute dot products
	float NdotH = clamp(dot(N,H), 0.0, 1.0);
	float NdotV = clamp(dot(N,V), 0.0, 1.0);
	float NdotL = clamp(dot(N,L), 0.0, 1.0);
	float LdotH = clamp(dot(L,H), 0.0, 1.0);

	//We compute the reflection in base to the color and the metalness
	vec3 f0 = mix( vec3(0.5), albedo, metalness );

	//Metallic materials do not have diffuse
	vec3 diffuse_color = (1.0 - metalness) * albedo;

	//Compute the specular
	vec3 specular;
	if(specular_light) specular = specularBRDF( linear_roughness, f0, NdotH, NdotV, NdotL, LdotH);

	//Compute the diffuse
	vec3 diffuse;
	if(u_diffuse_reflection == 0) //Lambertian reflectance
	{
		diffuse = diffuse_color * LambertBRDF(); 
	}
	else if(u_diffuse_reflection == 1)//Burley diffuse
	{
		diffuse = diffuse_color * BurleyBRDF(NdotV,NdotL,LdotH,linear_roughness); 
	}

	//Add diffuse and specular reflection
	vec3 direct_light = specular + diffuse;

	//Compute how much light received the pixel
	vec3 light_factor = light_color * light_intensity * light_attenuation * shadow_factor;

	//Modulate direct light by light received
	vec3 light = direct_light * light_factor;

	//Return light computation
	return light;	
}

\gamma_correction

//Gamma support uniform
uniform bool u_gamma_correction;

vec3 degamma(in vec3 color)
{
	if(u_gamma_correction) return pow(color,vec3(2.2));
	else return color;
}

vec4 degamma(in vec4 color)
{
	if(u_gamma_correction) return vec4(pow(color.rgb,vec3(2.2)),color.a);
	else return color;
}

vec3 gamma(in vec3 color)
{
	if(u_gamma_correction)
	{
		vec3 gamma_factor = vec3(1.0 / 2.2);
		return pow(color,gamma_factor);
	} 
	else return color;
}

vec4 gamma(in vec4 color)
{
	if(u_gamma_correction)
	{
		vec3 gamma_factor = vec3(1.0 / 2.2);
		return vec4(pow(color.rgb,gamma_factor),color.a);
	} 
	else return color;
}

\tone_mapper

//Uniforms
uniform bool u_tone_mapper;
uniform float u_color_scale; //color scale before tonemapper
uniform float u_average_illumination; 
uniform float u_white_illumination;

vec4 map_tone(in vec4 color) 
{

	if(u_tone_mapper)
	{
		float lum = dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));
		float L = (u_color_scale / u_average_illumination) * lum;
		float Ld = (L * (1.0 + L / u_white_illumination)) / (1.0 + L);

		color.rgb = (color.rgb / lum) * Ld;
		color.rgb = max(color.rgb, vec3(0.001));
	}

	return color;
}

vec3 map_tone(in vec3 color) 
{

	if(u_tone_mapper)
	{
		float lum = dot(color, vec3(0.2126, 0.7152, 0.0722));
		float L = (u_color_scale / u_average_illumination) * lum;
		float Ld = (L * (1.0 + L / u_white_illumination)) / (1.0 + L);

		color = (color / lum) * Ld;
		color = max(color, vec3(0.001));
	}

	return color;
}

\HBAO

uniform float screen_width;
uniform float screen_height;
uniform float u_znear;
uniform float u_zfar;
uniform float u_fov;
uniform float u_aspect_ratio;

uniform mat4 u_viewprojection;
uniform mat4 u_inverse_viewprojection;

//USER VARIABLES-----------------------------------------------

const float intensity = 0.5;            //Intensity of the AO effect
const float sampleRadius = 2.0;         //Radius of the AO, bigger values need more performance
const float sampleDirections = 8.0;    //Main sample count, affects performance heavily 
const float sampleSteps = 8.0;         //SubSample count for path walking, affects performance
const bool useAttenuation = true;       //Applies attenuation to each AO sample, true = better quality, off = better performance
const float attenuationScale = 0.3;     //Depth scale of the attenuation, different values look better depending on your scene
const float angleBias = 0.05;            //Brightens up the AO effect. Higer values mean less noise but less accuracy
const bool noise = true;                //Use noise instead of pattern for sample dithering, much slower but EXTREMLY better looking
const float noiseamount = 0.8;          //Per-Pixel noise amount, bigger values need more performance
const float jitterAmount = 0.8;         //Per-Sample noise amount, bigger values need more performance
const float lumInfluence = 0.5;         //Influence of the luminance on the AO effect
const vec3 aoColor = vec3(0.264, 0.531, 1.0) * 0.4; // Color of the AO effect
const bool onlyAO = true;                //Only show AO pass for debugging
const bool externalBlur = false;         //Store AO in alpha pass for a later blur
const float fogCutoff = 50.0;            // distance where AOu cuts off

//OTHER VARIABLES-------------------------------------------------------------

float thfov = tan(u_fov * 0.0087266462597222);
float TWO_PI = 6.283185307;
float pW = 1.0/screen_width;
float pH = 1.0/screen_height;
vec2 noiseOffset2d = vec2(max(1.0 - noiseamount, 0.0), 0.0);

vec3 getLinearColor(vec2 coord)
{    
    vec3 C = vec3(texture2D(albedo_texture, coord));
    C.r = pow(C.r, 2.2);
    C.g = pow(C.g, 2.2);
    C.b = pow(C.b, 2.2);
    return C.rgb;
}


vec3 sRGBToLinear(vec3 C)
{
    C.r = pow(C.r, 2.2);
    C.g = pow(C.g, 2.2);
    C.b = pow(C.b, 2.2);
    return C.rgb;
}


vec3 linearTosRGB(vec3 C)
{
    C.r = pow(C.r, 0.45454545);
    C.g = pow(C.g, 0.45454545);
    C.b = pow(C.b, 0.45454545);
    return C.rgb;
}


float getLinearDepth(vec2 coord)
{
    float zdepth = texture2D(depth_texture, coord).x;
    return u_zfar*u_znear / (u_zfar + zdepth * (u_znear - u_zfar));
}


vec3 getViewVector(vec2 coord)
{
    vec2 ndc = (coord * 2.0 - 1.0);
    return vec3(ndc.x*thfov, ndc.y*thfov/u_aspect_ratio, 1.0);
}


vec3 getViewPosition(vec2 coord)
{
    return getViewVector(coord) * getLinearDepth(coord);
}

vec3 getViewNormal(vec2 coord)
{
	return normalize((texture2D(normal_texture, coord).rgb - vec3(0.5)) * vec3(-2.0, -2.0, 2.0));
}


const float rand(vec2 co) {
    if (noise) {
        return fract(sin(dot(co.xy,vec2(12.9898,78.233)*4.0)) * 43758.5453)*2.0-1.0;
    } else {
        return ((fract(1.0-co.s*(screen_width/2.0))*0.3)+(fract(co.t*(screen_height/2.0))*0.6))*2.0-1.0;
    }
}

vec2 rand2D(vec2 coord) {
    float noiseX = ((fract(1.0-coord.s*(screen_width/2.0))*0.25)+(fract(coord.t*(screen_height/2.0))*0.75))*2.0-1.0;
    float noiseY = ((fract(1.0-coord.s*(screen_width/2.0))*0.75)+(fract(coord.t*(screen_height/2.0))*0.25))*2.0-1.0;
    
    if (noise)
    {
        noiseX = clamp(fract(sin(dot(coord ,vec2(12.9898,78.233))) * 43758.5453),0.0,1.0)*2.0-1.0;
        noiseY = clamp(fract(sin(dot(coord ,vec2(12.9898,78.233)*2.0)) * 43758.5453),0.0,1.0)*2.0-1.0;
    }
    return (normalize(vec2(noiseX,noiseY)) * noiseamount) + noiseOffset2d;
}

const mat4 getViewProjectionMatrix() {
    mat4 result;
    
    float frustumDepth = u_zfar - u_znear;
    float oneOverDepth = 1 / frustumDepth;


    result[0][0] = 1 / thfov;
    result[1][1] = u_aspect_ratio * result[0][0];
    result[2][2] = u_zfar * oneOverDepth;
    result[2][3] = 1;
    result[3][2] = (-u_zfar * u_znear) * oneOverDepth;
    
    return result;
}

mat4 VPM = getViewProjectionMatrix();
mat4 viewProjectionInverseMatrix  = inverse(VPM);
    
float radiusSS = sampleRadius;
vec4 temp0 = viewProjectionInverseMatrix * vec4(0.0, 0.0, -1.0, 1.0);
vec4 temp1 = viewProjectionInverseMatrix * vec4(radiusSS, 0.0, -1.0, 1.0);
float outDist = length(temp1.xyz - temp0.xyz);
float fovFact = tan(radiusSS * u_fov * 0.0087266462597222);
    
float theta = TWO_PI / float(sampleDirections);
float cosTheta = cos(theta);
float sinTheta = sin(theta);
mat2 deltaRotationMatrix = mat2(cosTheta, -sinTheta, sinTheta, cosTheta);

vec2 sampleNoise = normalize(rand2D(v_uv));
mat2 rotationMatrix = mat2(sampleNoise.x, -sampleNoise.y, sampleNoise.y,  sampleNoise.x);

float computeOcclusion()
{
    
    vec3 color = texture2D(albedo_texture,v_uv).rgb;
    
    vec3 originVS = getViewPosition(v_uv);
    vec3 normalVS = getViewNormal(v_uv);
    
    if(originVS.z > fogCutoff)
    {
        return 1.0;
    }
    
    const float radiusWS = min(tan(radiusSS * u_fov * 0.0087266462597222) * originVS.z, length(temp0.xyz - temp1.xyz));
    vec2 deltaUV = vec2(1.0, 0.0) * (radiusSS / (float(sampleDirections * sampleSteps) + 1.0));

    deltaUV = rotationMatrix * deltaUV;   
     
    float occlusion = 0.0;
    float jitter = rand(v_uv) * jitterAmount;
    
    for(int i = 0; i < sampleDirections; i++) {
        deltaUV = deltaRotationMatrix * deltaUV;
        
        vec2 sampleDirUV = deltaUV / originVS.z * vec2(20.0);
        float oldAngle = angleBias;
        
        for(int j = 0; j < sampleSteps; j++) {
            vec2 offsetNoise = mod(jitter + vec2(j * 0.429, j * 0.555), 1.0);
            vec2 sampleUV = v_uv + (mix(vec2(1.0), offsetNoise, jitterAmount) * sampleDirUV);
            vec3 sampleVS = getViewPosition(sampleUV);
            vec3 sampleDirVS = (sampleVS - originVS);
            
            float gamma = 1.570796326 - acos(dot(normalVS, normalize(sampleDirVS)));
            
            if (gamma > oldAngle) {
                float value = sin(gamma) - sin(oldAngle);
                
                if(useAttenuation) {
                    float attenuation = clamp(1.0 - pow(length(sampleDirVS) / radiusWS * attenuationScale, 2.0), 0.0, 1.0);
                    occlusion += attenuation * value;
                } else {
                    occlusion += value;
                }
                
                oldAngle = gamma;
            }
        }
    }
    
    occlusion = 1.0 - occlusion / float(sampleDirections);
    occlusion = clamp(pow(occlusion, 1.0 + intensity), 0.0, 1.0);
    
    vec3 lumcoeff = vec3(0.299,0.587,0.114);
    float lum = dot(color.rgb, lumcoeff) * lumInfluence;
    
    occlusion = lum + ((1.0 - lum) * occlusion);
    
    return occlusion;
}

\lighting

//Scene uniforms
uniform vec3 u_camera_position;
uniform int u_light_model;
uniform vec3 u_ambient_light;
uniform bool u_specular_light;
uniform bool u_occlusion;
uniform bool u_shadows;
uniform int u_num_lights;
uniform float u_num_shadows;
uniform sampler2D u_shadow_atlas;


//Single pass maximum number of lights to render
const int MAX_LIGHTS = 5;

//Global lights uniforms (Singlepass)
uniform vec3 u_lights_position[MAX_LIGHTS];
uniform vec3 u_lights_color[MAX_LIGHTS];
uniform float u_lights_intensity[MAX_LIGHTS];
uniform float u_lights_max_distance[MAX_LIGHTS];
uniform int u_lights_type[MAX_LIGHTS];

//Global light uniforms (Multipass)
uniform vec3 u_light_position;
uniform vec3 u_light_color;
uniform float u_light_intensity;
uniform float u_light_max_distance;
uniform int u_light_type;

//Spot lights uniforms (Singlepass)
uniform vec3 u_spots_direction[MAX_LIGHTS];
uniform vec2 u_spots_cone[MAX_LIGHTS];

//Spot light uniforms (Multipass)
uniform vec3 u_spot_direction;
uniform vec2 u_spot_cone;

//Directional lights uniforms (Singlepass)
uniform vec3 u_directionals_front[MAX_LIGHTS];

//Directional light uniforms (Multipass)
uniform vec3 u_directional_front;

//Shadows (Singlepass)
uniform bool u_cast_shadows[MAX_LIGHTS];
uniform float u_shadows_index[MAX_LIGHTS];
uniform float u_shadows_bias[MAX_LIGHTS];
uniform mat4 u_shadows_vp[MAX_LIGHTS];

//Shadows (Multipass)
uniform bool u_cast_shadow;
uniform float u_shadow_index;
uniform float u_shadow_bias;
uniform mat4 u_shadow_vp;

float computeLightAttenuation(in float light_distance, in float light_max_distance)
{
    //Light Attenuation
    light_max_distance = max(light_max_distance,0.0);
    float attenuation_factor =  light_max_distance - light_distance;
	attenuation_factor /= light_max_distance;
	attenuation_factor = pow(max( attenuation_factor, 0.0 ),2.0);
	return attenuation_factor;
}

vec3 Singlepass(const in vec3 normal_vector, const in vec3 view_vector, const in vec3 world_position, const in vec3 albedo, const in vec3 omr)
{
	//Compute ambient factor
	float occlusion_factor = 1.0;
	if(u_occlusion) occlusion_factor = computeOcclusion();

	//Set ambient light to phong light
	vec3 light = occlusion_factor * u_ambient_light;

	//Single pass for loop
	for( int i = 0; i < MAX_LIGHTS; ++i )
	{
		if(i < u_num_lights)
		{
			//Light intensisty
			float light_intensity = u_lights_intensity[i];

			//Compute shadow factor 
			float shadow_factor = 1.0;
			if(u_cast_shadows[i]) shadow_factor = testShadowMap(u_shadows_index[i], u_shadows_bias[i], u_shadows_vp[i], u_num_shadows, u_shadow_atlas, world_position);

			if(u_lights_type[i] == 0) //point light
			{
				//Light vector
				vec3 light_vector = u_lights_position[i] - world_position;

				//Light distance
				float light_distance = length(light_vector);

				//Light attenuation
				float light_attenuation = computeLightAttenuation(light_distance,u_lights_max_distance[i]);

				//Normalize light vector
				light_vector /= light_distance;

				//Light Model
				if(u_light_model == 0) //Lambert aproximation
				{
					light += PhongEquation(u_lights_color[i], light_vector, light_intensity, light_attenuation, normal_vector, view_vector, omr.y, omr.z, shadow_factor, u_specular_light);
				}
				else if(u_light_model == 1) //PBR model
				{
					light += BRDF(light_vector, view_vector, normal_vector, albedo, omr.y, omr.z, u_lights_color[i], light_intensity, light_attenuation, shadow_factor, u_specular_light);
				}

			}
			else if(u_lights_type[i] == 1) //spotlight
			{
				//Light vector
				vec3 light_vector = u_lights_position[i] - world_position;

				//Light distance
				float light_distance = length(light_vector);

				//Light attenuation
				float light_attenuation = computeLightAttenuation(light_distance,u_lights_max_distance[i]);

				//Normalize light vector
				light_vector /= light_distance;

				//Orient spot vector
				vec3 spot_vector = -u_spots_direction[i];

				//Compute the cosine of the angle between previous vectors
				float spot_cosine = dot(light_vector,spot_vector);

				//Check if the pixel is within the cone
				if(spot_cosine >= u_spots_cone[i].y)
				{
					//Light intesity
					light_intensity *= pow(spot_cosine,max(u_spots_cone[i].x,0.0));

					//Light Model
					if(u_light_model == 0) //Lambert aproximation
					{
						light += PhongEquation(u_lights_color[i], light_vector, light_intensity, light_attenuation, normal_vector, view_vector, omr.y, omr.z, shadow_factor, u_specular_light);
					}
					else if(u_light_model == 1) //PBR model
					{
						light += BRDF(light_vector, view_vector, normal_vector, albedo, omr.y, omr.z, u_lights_color[i], light_intensity, light_attenuation, shadow_factor, u_specular_light);
					}
				}

			}
			else if(u_lights_type[i] == 2) //directional light
			{
				//Light vector
				vec3 light_vector = u_directionals_front[i];

				//Light distance
				float light_distance = length(light_vector);

				//Normalize light vector
				light_vector /= light_distance;

					//Light Model
					if(u_light_model == 0) //Lambert aproximation
					{
						light += PhongEquation(u_lights_color[i], light_vector, light_intensity, 1.0, normal_vector, view_vector, omr.y, omr.z, shadow_factor, u_specular_light);
					}
					else if(u_light_model == 1) //PBR model
					{
						light += BRDF(light_vector, view_vector, normal_vector, albedo, omr.y, omr.z, u_lights_color[i], light_intensity, 1.0, shadow_factor, u_specular_light);
					}
			}			
		}
	}

	return light;
}

vec3 Multipass(const in vec3 normal_vector, const in vec3 view_vector, const in vec3 world_position, const in vec3 albedo, const in vec3 omr)
{
	//Compute ambient factor
	float occlusion_factor = 1.0;
	if(u_occlusion) occlusion_factor = computeOcclusion();

	//Set ambient light to phong light
	vec3 light = occlusion_factor * u_ambient_light;

	//Light intesity
	float light_intensity = u_light_intensity;

	//Compute shadow factor 
	float shadow_factor = 1.0;
	if(u_cast_shadow) shadow_factor = testShadowMap(u_shadow_index, u_shadow_bias, u_shadow_vp, u_num_shadows, u_shadow_atlas, world_position);

	if(u_light_type == 0) //point light
	{
		//Light vector
		vec3 light_vector = u_light_position - world_position;

		//Light distance
		float light_distance = length(light_vector);

		//Light attenuation
		float light_attenuation = computeLightAttenuation(light_distance,u_light_max_distance);

		//Normalize light vector
		light_vector /= light_distance;

		//Light Model
		if(u_light_model == 0) //Lambert aproximation
		{
			light += PhongEquation(u_light_color, light_vector, light_intensity, light_attenuation, normal_vector, view_vector, omr.y, omr.z, shadow_factor, u_specular_light);
		}
		else if(u_light_model == 1) //PBR model
		{
			light += BRDF(light_vector, view_vector, normal_vector, albedo, omr.y, omr.z, u_light_color, light_intensity, light_attenuation, shadow_factor, u_specular_light);
		}

	}
	else if(u_light_type == 1) //spotlight
	{
		//Light vector
		vec3 light_vector = u_light_position - world_position;

		//Light distance
		float light_distance = length(light_vector);

		//Light attenuation
		float light_attenuation = computeLightAttenuation(light_distance,u_light_max_distance);

		//Normalize light vector
		light_vector /= light_distance;

		//Orient spot vector
		vec3 spot_vector = -u_spot_direction;

		//Compute the cosine of the angle between previous vectors
		float spot_cosine = dot(light_vector,spot_vector);

		//Check if the pixel is within the cone
		if(spot_cosine >= u_spot_cone.y)
		{
			//Light intesity
			light_intensity *= pow(spot_cosine,max(u_spot_cone.x,0.0));

			//Light Model
			if(u_light_model == 0) //Lambert aproximation
			{
				light += PhongEquation(u_light_color, light_vector, light_intensity, light_attenuation, normal_vector, view_vector, omr.y, omr.z, shadow_factor, u_specular_light);
			}
			else if(u_light_model == 1) //PBR model
			{
				light += BRDF(light_vector, view_vector, normal_vector, albedo, omr.y, omr.z, u_light_color, light_intensity, light_attenuation, shadow_factor, u_specular_light);
			} 
		}
	}
	else if(u_light_type == 2) //directional light
	{
		//Light vector
		vec3 light_vector = u_directional_front;

		//Light distance
		float light_distance = length(light_vector);

		//Normalize light vector
		light_vector /= light_distance;

		//Light Model
		if(u_light_model == 0) //Lambert aproximation
		{
			light += PhongEquation(u_light_color, light_vector, light_intensity, 1.0, normal_vector, view_vector, omr.y, omr.z, shadow_factor, u_specular_light);
		}
		else if(u_light_model == 1) //PBR model
		{
			light += BRDF(light_vector, view_vector, normal_vector, albedo, omr.y, omr.z, u_light_color, light_intensity, 1.0, shadow_factor, u_specular_light);
		}
	}

	return light;
}

\pixel.vs

#version 330 core

in vec3 a_vertex;
in vec3 a_normal;
in vec2 a_coord;

uniform mat4 u_model;
uniform mat4 u_viewprojection;

//This will store interpolated variables for the pixel shader
out vec3 v_normal;
out vec3 v_world_position;
out vec2 v_uv;

uniform float u_time;

void main()
{		
	//Calculate the normal in camera space (the NormalMatrix is like ViewMatrix but without traslation)
	v_normal = (u_model * vec4( a_normal, 0.0) ).xyz;

	//Calculate the vertex in object space
	vec3 position = a_vertex;
	v_world_position = (u_model * vec4( position, 1.0) ).xyz;

	//Store the texture coordinates
	v_uv = a_coord;

	//Calculate the position of the vertex using the matrices
	gl_Position = u_viewprojection * vec4( v_world_position, 1.0 );
}

\nolights.fs

#version 330 core

//Interpolated variables
in vec2 v_uv;

//Textures
uniform sampler2D u_color_texture;
uniform sampler2D u_emissive_texture;

//Scene uniforms
uniform float u_time;
uniform bool u_emissive_materials;

//Prefab uniforms
uniform vec4 u_color;
uniform float u_alpha_cutoff;
uniform bool u_normal_mapping;
uniform vec3 u_emissive_factor;

//Output
out vec4 FragColor;

//Includes
#include gamma_correction
#include tone_mapper

void main()
{
	//Material color
	vec4 color = degamma(map_tone(u_color));

	//Load color texture values with texture interpolated coordinates
	color *= degamma(map_tone(texture2D( u_color_texture, v_uv )));	

	//Mask
	if(color.a < u_alpha_cutoff)
		discard;

	//Emissive materials
	if(u_emissive_materials)
	{
		vec3 emissive_light = u_emissive_factor * degamma(texture2D(u_emissive_texture,v_uv).xyz);
		color.rgb += emissive_light;
	}

	//Output: Gamma space color
	FragColor = gamma(color);

}

\forward.fs

#version 330 core

//Interpolated variables
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;

//Textures
uniform sampler2D u_color_texture;
uniform sampler2D u_normal_texture;
uniform sampler2D u_depth_texture;
uniform sampler2D u_omr_texture;
uniform sampler2D u_emissive_texture;

//Scene uniforms
uniform int u_light_pass;
uniform float u_time;
uniform bool u_last_iteration;

//Prefab uniforms
uniform vec4 u_color;
uniform float u_alpha_cutoff;
uniform bool u_normal_mapping;
uniform vec3 u_emissive_factor;

//Output
out vec4 FragColor;

//Textures
const sampler2D albedo_texture = u_color_texture;
const sampler2D normal_texture = u_normal_texture;
const sampler2D depth_texture = u_depth_texture;

//Includes
#include normal_mapping
#include shadow_test
#include phong
#include PBR
#include gamma_correction
#include tone_mapper
#include HBAO
#include lighting

void main()
{
	//Material color
	vec4 color = degamma(map_tone(u_color));

	//Load texture values with texture interpolated coordinates
	vec3 tangent_space_normal = texture2D( u_normal_texture, v_uv ).xyz;
	color *= degamma(map_tone(texture2D( u_color_texture, v_uv )));	
	vec3 omr = texture2D(u_omr_texture,v_uv).xyz;

	//Mask
	if(color.a < u_alpha_cutoff)
		discard;

	//Interpolated normal
	vec3 interpolated_normal = normalize(v_normal);

	//Normal mapping
	vec3 normal_vector;
	if(u_normal_mapping) normal_vector = perturbNormal(interpolated_normal, v_world_position, v_uv, tangent_space_normal);//Normal map
	else normal_vector = interpolated_normal;//Interpolated Normal

	//View vector
	vec3 view_vector = normalize(u_camera_position - v_world_position);

	//Compute light
	vec3 light;
	if(u_light_pass == 0) //Multi pass lighting
	{
		light = Multipass(normal_vector, view_vector, v_world_position, color.xyz, omr);
	} 
	else if(u_light_pass == 1) //Single pass lighting
	{
		light = Singlepass(normal_vector, view_vector, v_world_position, color.xyz, omr);
	} 
	
	//Final color
	color.rgb *= light;
	if(u_last_iteration)
	{
		vec3 emissive_light = u_emissive_factor * degamma(texture2D(u_emissive_texture,v_uv).xyz);
		color.rgb += emissive_light;
	}

	//Output: Gamma space color
	FragColor = gamma(color);
}

\quad.vs

#version 330 core

in vec3 a_vertex;
in vec2 a_coord;
out vec2 v_uv;

void main()
{	
	v_uv = a_coord;
	gl_Position = vec4( a_vertex, 1.0 );
}

\deferred.fs

#version 330 core

//Interpolated variables
in vec2 v_uv;

//Textures
uniform sampler2D u_gb0_texture;
uniform sampler2D u_gb1_texture;
uniform sampler2D u_gb2_texture;
uniform sampler2D u_depth_texture;

//Scene uniforms
uniform int u_light_pass;
uniform bool u_emissive_materials;
uniform mat4 u_inverse_viewprojection;
uniform vec2 u_iRes;
uniform float u_time;
uniform bool u_last_iteration;

//Output
layout(location = 0) out vec3 I0;
layout(location = 1) out vec3 I1;

//Textures
const sampler2D albedo_texture = u_gb0_texture;
const sampler2D normal_texture = u_gb1_texture;
const sampler2D depth_texture = u_depth_texture;

//Includes
#include normal_mapping
#include shadow_test
#include phong
#include PBR
#include gamma_correction
#include HBAO
#include lighting

void main()
{
	//Extract uvs from pixel screenpos
	vec2 uv = gl_FragCoord.xy * u_iRes;

	//Load texture values with screen interpolated coordinates
	vec4 gb0 = texture2D( u_gb0_texture, uv );
	vec4 gb1 = texture2D( u_gb1_texture, uv );
	vec4 gb2 = texture2D( u_gb2_texture, uv );
	float depth = texture2D( u_depth_texture, uv ).x;

	//Discard background pixels
	if(depth == 1.0)
		discard;

	//Assign each buffer value to its material property
	vec3 color = degamma(gb0.xyz);
	vec3 normal_vector = (gb1.xyz * 2.0 - vec3(1.0)); //normals must be converted from 0..1 to -1..+1
	vec3 omr = gb2.xyz;

	//Renormalize normal in case of data loss
	normal_vector = normalize(normal_vector);
	
	//Compute world position
	vec4 screen_pos = vec4(uv.x * 2.0 - 1.0, uv.y * 2.0 - 1.0, depth * 2.0 - 1.0, 1.0);
	vec4 proj_worldpos = u_inverse_viewprojection * screen_pos;
	vec3 world_position = proj_worldpos.xyz / proj_worldpos.w;

	//View vector
	vec3 view_vector = normalize(u_camera_position - world_position);

	//Compute light
	vec3 light;
	if(u_light_pass == 0) //Multi pass lighting
	{
		light = Multipass(normal_vector, view_vector, world_position, color.xyz, omr);
	} 
	else if(u_light_pass == 1) //Single pass lighting
	{
		light = Singlepass(normal_vector, view_vector, world_position, color.xyz, omr);
	} 

	//Final color
	color *= light;
	if(u_emissive_materials && u_last_iteration)
	{
		vec3 emissive_light = vec3(gb0.a,gb1.a,gb2.a);
		color += degamma(emissive_light);
	} 

	//Fill buffers
	I0 = gamma(color);
	I1 = light;

}

\gbuffers.fs

#version 330 core

//Interpolated variables
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;

//Textures
uniform sampler2D u_color_texture;
uniform sampler2D u_emissive_texture;
uniform sampler2D u_omr_texture;
uniform sampler2D u_normal_texture;
uniform sampler2D u_shadow_atlas;

//Scene uniforms
uniform vec3 u_camera_position;
uniform float u_time;

//Prefab uniforms
uniform vec4 u_color;
uniform float u_alpha_cutoff;
uniform bool u_normal_mapping;
uniform vec3 u_emissive_factor;

//Output
layout(location = 0) out vec4 GB0;
layout(location = 1) out vec4 GB1;
layout(location = 2) out vec4 GB2;

//Includes
#include normal_mapping
#include gamma_correction
#include tone_mapper

void main()
{
	//Material color
	vec4 color = degamma(map_tone(u_color));

	//Load texture values with texture interpolated coordinates
	color *= degamma(map_tone(texture2D( u_color_texture, v_uv )));
	vec3 tangent_space_normal = texture2D( u_normal_texture, v_uv ).xyz; 
	vec3 omr = texture2D(u_omr_texture,v_uv).xyz;
	vec3 emissive_color = u_emissive_factor * degamma(texture2D(u_emissive_texture,v_uv).xyz);

	//Mask
	if(color.a < u_alpha_cutoff)
		discard;

	//Interpolated normal
	vec3 interpolated_normal = normalize(v_normal);

	//Normal mapping
	vec3 normal_vector;
	if(u_normal_mapping) normal_vector = perturbNormal(interpolated_normal, v_world_position, v_uv, tangent_space_normal);//Normal map
	else normal_vector = interpolated_normal;//Interpolated Normal

	//Compress normal to space [0,...,1]
	normal_vector = normal_vector * 0.5 + vec3(0.5);

	//Reconvert color to gamma space again
	color = gamma(color);
	emissive_color = gamma(emissive_color);

	//Fill buffers
	GB0 = vec4(color.rgb,emissive_color.x);
	GB1 = vec4(normal_vector, emissive_color.y);
	GB2 = vec4(omr,emissive_color.z);
}


\emissive.fs

#version 330 core

//Varying
in vec2 v_uv;

//Textures
uniform sampler2D u_color_texture;
uniform sampler2D u_normal_texture;
uniform sampler2D u_omr_texture;

//Output
out vec4 FragColor;

void main()
{
	vec3 emissive_factor;
	emissive_factor.r = texture2D(u_color_texture,v_uv).a;
	emissive_factor.g = texture2D(u_normal_texture,v_uv).a;
	emissive_factor.b = texture2D(u_omr_texture,v_uv).a;

	FragColor = vec4(emissive_factor,1.0);
}

\linearize.fs

#version 330 core

uniform vec2 u_camera_nearfar;
uniform sampler2D u_texture; //depth map
in vec2 v_uv;
out vec4 FragColor;

void main()
{
	float n = u_camera_nearfar.x;
	float f = u_camera_nearfar.y;
	float z = texture2D(u_texture,v_uv).x;
	if( n == 0.0 && f == 1.0 )
		FragColor = vec4(z);
	else
		FragColor = vec4( n * (z + 1.0) / (f + n - z * (f - n)) );
}

\linearize_atlas.fs

#version 330 core

//Varying variables
in vec2 v_uv;

//Uniforms
uniform vec2 u_camera_nearfar;
uniform sampler2D u_texture; //depth map
uniform float u_shadow_index;
uniform float u_num_shadows;

//Output
out vec4 FragColor;

void main()
{
	//Shadow atlas coordinates
	vec2 shadow_uv = v_uv;
	shadow_uv.x = (shadow_uv.x + u_shadow_index)/u_num_shadows;

	float n = u_camera_nearfar.x;
	float f = u_camera_nearfar.y;
	float z = texture2D(u_texture,shadow_uv).x;

	if( n == 0.0 && f == 1.0 )
		FragColor = vec4(z);
	else
		FragColor = vec4( n * (z + 1.0) / (f + n - z * (f - n)) );
}

\depth.vs


#version 330 core

in vec3 a_vertex;

uniform mat4 u_model;
uniform mat4 u_viewprojection;

void main()
{	
	//calcule the screen position of the vertex using the matrices
	vec3 world_position = (u_model * vec4( a_vertex, 1.0) ).xyz;
	gl_Position = u_viewprojection * vec4( world_position, 1.0 );
}

\color.fs

#version 330 core

uniform vec4 u_color;

out vec4 FragColor;

void main()
{
	FragColor = u_color;
}